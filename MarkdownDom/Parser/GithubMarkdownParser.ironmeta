using System;
using System.Linq;
using Net.Yingzxu.MarkdownDom;
using Net.Yingzxu.MarkdownDom.Base;
using Net.Yingzxu.MarkdownDom.Elements;

// This grammar is far more complicated than 
// it needs to be, in order to demonstrate
// the features of the IronMeta system.

ironmeta GithubMarkdown<char, MarkdownElementBase> : IronMeta.Matcher.CharMatcher<MarkdownElementBase>
{
    Document = Block*:block EOF -> { 
		MarkdownDocument root = new MarkdownDocument(); 
		root.AddChildrenElements(block.Results.AsEnumerable<MarkdownElementBase>());
		return root;
	}	;
    Block = 
		LineBreak
		| Head: head -> {head}
		| Blockquote : quote -> {quote}
		| Paragraph : para -> {para}
		
	;

	Head = HeadSymbol:symbol HeadText:text ->
		{	HeaderElement head = new HeaderElement(); 
			head.Size=symbol.Results.First().TextContent.Length;
			head.TextContent=text.Results.First().TextContent;
			//remove the tailing #
			head.TextContent=head.TextContent.TrimEnd('#');
			return head;
		};
	Paragraph = InlineText:text -> 
		{
			GeneralElement para = new GeneralElement(ElementType.Paragraph); 
			para.TextContent=text.Results.First().TextContent;
			return para;
		};
	Blockquote = BlockquoteSymbol:symbol (Head | Paragraph)*:inner LineBreak? (((LineBreak* Blockquote) | Paragraph) LineBreak?)*:children-> 
		{
			BlockquoteElement block = new BlockquoteElement(); 
			block.QuoteLevel=symbol.Results.First().TextContent.Length;
			block.AddChildrenElements(inner.Results.AsEnumerable<MarkdownElementBase>());
			IEnumerable<MarkdownElementBase> innerBlocks =  children.Results.AsEnumerable<MarkdownElementBase>();
            foreach (MarkdownElementBase innerBlock in innerBlocks)
            {
                if (innerBlock.Type == ElementType.Blockquote && (innerBlock as BlockquoteElement).QuoteLevel <= block.QuoteLevel) 
                {
                    block.AddChildrenElements(innerBlock.Children);
                }
                else
                {
                    block.AddChildElement(innerBlock);
                }
            } 
			return block;
		};

	LineBreak =  '\r' '\n'? | '\n' ;
	HeadText = (~LineBreak .)* -> {
		string match=Input(_IM_Result) ;
		GeneralElement text = new GeneralElement(ElementType.Text); 
		text.TextContent=match;
		return text;}; 
	//PlainText Bold or Italic etc..
	InlineText =  (~('\n' | '\r') .)+ -> {
		string match=Input(_IM_Result) ;
		GeneralElement text = new GeneralElement(ElementType.Text); 
		text.TextContent=match;
		return text;}; 
	HeadSymbol = '#'+ -> {
		string match=Input(_IM_Result) ;
		GeneralElement text = new GeneralElement(ElementType.Text); 
		text.TextContent=match;
		return text;}; 
	BlockquoteSymbol = '>'+ -> {
		string match=Input(_IM_Result) ;
		GeneralElement text = new GeneralElement(ElementType.Text); 
		text.TextContent=match;
		return text;}; 
	DG = ['0'-'9'];
	EN = ['a'-'z'] | ['A'-'Z'];
    WS = ' ' | '\n' | '\r' | '\t'; 
	EOF = ~. ;
} 
